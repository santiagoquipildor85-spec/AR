<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Realidad Aumentada - Detector de Formas</title>
    <link rel="stylesheet" href="styles.css">
    <link rel="stylesheet" href="ar-styles.css">
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#764ba2">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="default">
    <style>
        @keyframes pulse {
            0%, 100% { opacity: 0.7; transform: scale(1); }
            50% { opacity: 1; transform: scale(1.05); }
        }
    </style>
</head>
<body class="ar-body">
    <div class="ar-container-fullscreen">
        <!-- Botón de cerrar minimalista -->
        <button id="backBtn" class="btn-close">×</button>
        
        <!-- Cámara fullscreen -->
        <div class="camera-fullscreen">
            <video id="video" autoplay playsinline></video>
            <canvas id="canvas"></canvas>
            <div class="ar-overlay" id="arOverlay"></div>
        </div>

        <!-- Indicador de estado minimalista -->
        <div class="status-indicator" id="statusIndicator">
            <div class="status-dot"></div>
            <span id="statusText">Toca para iniciar</span>
        </div>
    </div>

    <script>
        // Sistema AR simplificado y funcional
        document.addEventListener('DOMContentLoaded', function() {
            console.log('Inicializando AR...');
            
            // Variables
            let isRunning = false;
            let stream = null;
            let animationId = null;
            
            // Elementos
            const video = document.getElementById('video');
            const canvas = document.getElementById('canvas');
            const ctx = canvas.getContext('2d');
            const arOverlay = document.getElementById('arOverlay');
            const statusIndicator = document.getElementById('statusIndicator');
            const statusText = document.getElementById('statusText');
            const statusDot = document.querySelector('.status-dot');
            const backBtn = document.getElementById('backBtn');
            
            // Función para actualizar estado
            function updateStatus(text, state) {
                if (statusText) statusText.textContent = text;
                if (statusDot) {
                    statusDot.className = 'status-dot';
                    if (state === 'active') statusDot.classList.add('active');
                    if (state === 'detecting') statusDot.classList.add('detecting');
                }
            }
            
            // Configurar canvas
            function setupCanvas() {
                if (video.videoWidth && video.videoHeight) {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    canvas.style.width = '100%';
                    canvas.style.height = '100%';
                }
            }
            
            // Limpiar overlay
            function clearOverlay() {
                while (arOverlay.firstChild) {
                    arOverlay.removeChild(arOverlay.firstChild);
                }
            }
            
            // Mostrar detección en posición específica
            function showDetectionAt(x, y, width, height) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = rect.width / canvas.width;
                const scaleY = rect.height / canvas.height;
                
                // Borde de detección
                const border = document.createElement('div');
                border.style.position = 'absolute';
                border.style.left = (x * scaleX) + 'px';
                border.style.top = (y * scaleY) + 'px';
                border.style.width = (width * scaleX) + 'px';
                border.style.height = (height * scaleY) + 'px';
                border.style.border = '3px solid #2ecc71';
                border.style.borderRadius = '4px';
                border.style.zIndex = '5';
                border.style.animation = 'pulse 1s infinite';
                
                // Texto flotante
                const card = document.createElement('div');
                card.style.position = 'absolute';
                card.style.left = ((x + width + 10) * scaleX) + 'px';
                card.style.top = (y * scaleY) + 'px';
                card.style.background = 'rgba(46, 204, 113, 0.9)';
                card.style.color = 'white';
                card.style.padding = '8px 12px';
                card.style.borderRadius = '6px';
                card.style.fontFamily = 'Arial, sans-serif';
                card.style.fontSize = '14px';
                card.style.zIndex = '10';
                card.style.boxShadow = '0 2px 8px rgba(0,0,0,0.3)';
                card.style.whiteSpace = 'nowrap';
                
                card.innerHTML = '<div style="font-weight: bold; margin-bottom: 2px;">👋 Hola</div><div style="font-size: 11px; opacity: 0.9;">DAyE 2025 Expo</div>';
                
                arOverlay.appendChild(border);
                arOverlay.appendChild(card);
            }
            
            // Sistema de tracking para seguir formas
            let trackedShapes = new Map();
            let shapeIdCounter = 0;
            
            // Loop de detección mejorado con tracking
            function detectLoop() {
                if (!isRunning) return;
                
                try {
                    if (video.videoWidth > 0) {
                        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                        
                        // Detectar forma L con múltiples métodos
                        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                        const detections = detectShapeMultiMethod(imageData);
                        
                        // Actualizar tracking
                        updateTracking(detections);
                        
                        // Limpiar y mostrar
                        clearOverlay();
                        displayTrackedShapes();
                        
                        // Actualizar estado
                        if (trackedShapes.size > 0) {
                            updateStatus(`${trackedShapes.size} forma(s) detectada(s)`, 'detecting');
                        } else {
                            updateStatus('Buscando formas...', 'active');
                        }
                    }
                } catch (error) {
                    console.error('Error:', error);
                }
                
                if (isRunning) {
                    animationId = requestAnimationFrame(detectLoop);
                }
            }
            
            // Detección múltiple para mejor precisión
            function detectShapeMultiMethod(imageData) {
                const detections = [];
                
                // Método 1: Detección de contraste alto
                detections.push(...detectByContrast(imageData));
                
                // Método 2: Detección por bordes
                detections.push(...detectByEdges(imageData));
                
                // Método 3: Detección por forma específica
                detections.push(...detectLShapeImproved(imageData));
                
                // Filtrar y combinar resultados
                return filterAndMergeDetections(detections);
            }
            
            // Método 1: Detección por contraste alto
            function detectByContrast(imageData) {
                const detections = [];
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                const step = 15;
                const regionSize = 60;
                
                for (let y = 0; y < height - regionSize; y += step) {
                    for (let x = 0; x < width - regionSize; x += step) {
                        const contrast = calculateContrast(data, x, y, regionSize, width);
                        
                        if (contrast > 80) { // Alto contraste = posible forma
                            const shapeScore = analyzeShapeInRegion(data, x, y, regionSize, width);
                            
                            if (shapeScore > 0.3) {
                                detections.push({
                                    x: x,
                                    y: y,
                                    width: regionSize,
                                    height: regionSize,
                                    confidence: shapeScore,
                                    method: 'contrast'
                                });
                            }
                        }
                    }
                }
                
                return detections;
            }
            
            // Método 2: Detección por bordes
            function detectByEdges(imageData) {
                const detections = [];
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                // Simplificado: buscar cambios bruscos de intensidad
                const step = 20;
                const regionSize = 70;
                
                for (let y = 0; y < height - regionSize; y += step) {
                    for (let x = 0; x < width - regionSize; x += step) {
                        const edgeScore = calculateEdgeScore(data, x, y, regionSize, width);
                        
                        if (edgeScore > 0.4) {
                            detections.push({
                                x: x,
                                y: y,
                                width: regionSize,
                                height: regionSize,
                                confidence: edgeScore,
                                method: 'edges'
                            });
                        }
                    }
                }
                
                return detections;
            }
            
            // Método 3: Detección de forma L mejorada
            function detectLShapeImproved(imageData) {
                const detections = [];
                const data = imageData.data;
                const width = imageData.width;
                const height = imageData.height;
                
                // Buscar patrones más específicos
                const sizes = [50, 70, 90, 120]; // Múltiples tamaños
                
                sizes.forEach(size => {
                    const step = Math.max(10, size / 4);
                    
                    for (let y = 0; y < height - size; y += step) {
                        for (let x = 0; x < width - size; x += step) {
                            const lScore = analyzeLPattern(data, x, y, size, width);
                            
                            if (lScore > 0.35) {
                                detections.push({
                                    x: x,
                                    y: y,
                                    width: size,
                                    height: size,
                                    confidence: lScore,
                                    method: 'L_pattern'
                                });
                            }
                        }
                    }
                });
                
                return detections;
            }
            
            // Calcular contraste en región
            function calculateContrast(data, startX, startY, size, width) {
                let minIntensity = 255;
                let maxIntensity = 0;
                
                for (let y = 0; y < size; y += 3) {
                    for (let x = 0; x < size; x += 3) {
                        const index = ((startY + y) * width + (startX + x)) * 4;
                        const intensity = (data[index] + data[index + 1] + data[index + 2]) / 3;
                        
                        minIntensity = Math.min(minIntensity, intensity);
                        maxIntensity = Math.max(maxIntensity, intensity);
                    }
                }
                
                return maxIntensity - minIntensity;
            }
            
            // Analizar forma en región
            function analyzeShapeInRegion(data, startX, startY, size, width) {
                let whitePixels = 0;
                let blackPixels = 0;
                let totalPixels = 0;
                
                for (let y = 0; y < size; y += 2) {
                    for (let x = 0; x < size; x += 2) {
                        const index = ((startY + y) * width + (startX + x)) * 4;
                        const intensity = (data[index] + data[index + 1] + data[index + 2]) / 3;
                        
                        totalPixels++;
                        if (intensity > 200) whitePixels++;
                        else if (intensity < 50) blackPixels++;
                    }
                }
                
                const ratio = Math.max(whitePixels, blackPixels) / totalPixels;
                return ratio > 0.3 && ratio < 0.8 ? ratio : 0;
            }
            
            // Calcular puntuación de bordes
            function calculateEdgeScore(data, startX, startY, size, width) {
                let edgeStrength = 0;
                let edgeCount = 0;
                
                for (let y = 1; y < size - 1; y += 3) {
                    for (let x = 1; x < size - 1; x += 3) {
                        const centerIndex = ((startY + y) * width + (startX + x)) * 4;
                        const rightIndex = ((startY + y) * width + (startX + x + 1)) * 4;
                        const bottomIndex = ((startY + y + 1) * width + (startX + x)) * 4;
                        
                        const centerIntensity = (data[centerIndex] + data[centerIndex + 1] + data[centerIndex + 2]) / 3;
                        const rightIntensity = (data[rightIndex] + data[rightIndex + 1] + data[rightIndex + 2]) / 3;
                        const bottomIntensity = (data[bottomIndex] + data[bottomIndex + 1] + data[bottomIndex + 2]) / 3;
                        
                        const gradientX = Math.abs(centerIntensity - rightIntensity);
                        const gradientY = Math.abs(centerIntensity - bottomIntensity);
                        const gradient = Math.sqrt(gradientX * gradientX + gradientY * gradientY);
                        
                        if (gradient > 30) {
                            edgeStrength += gradient;
                            edgeCount++;
                        }
                    }
                }
                
                return edgeCount > 5 ? (edgeStrength / edgeCount) / 255 : 0;
            }
            
            // Analizar patrón L específico
            function analyzeLPattern(data, startX, startY, size, width) {
                const third = size / 3;
                let lRegionPixels = 0;
                let nonLRegionPixels = 0;
                
                for (let y = 0; y < size; y += 2) {
                    for (let x = 0; x < size; x += 2) {
                        const index = ((startY + y) * width + (startX + x)) * 4;
                        const intensity = (data[index] + data[index + 1] + data[index + 2]) / 3;
                        const isWhite = intensity > 180;
                        
                        // Verificar si está en región L (parte vertical izquierda + horizontal inferior)
                        const inVertical = x < third && y > third;
                        const inHorizontal = y > third * 2 && x < third * 2;
                        const inLRegion = inVertical || inHorizontal;
                        
                        if (inLRegion && isWhite) {
                            lRegionPixels++;
                        } else if (!inLRegion && !isWhite) {
                            nonLRegionPixels++;
                        }
                    }
                }
                
                const totalExpected = (size * size) / 8; // Estimación
                const lScore = (lRegionPixels + nonLRegionPixels) / totalExpected;
                
                return Math.min(1.0, lScore);
            }
            
            // Filtrar y combinar detecciones de múltiples métodos
            function filterAndMergeDetections(detections) {
                const filtered = [];
                const minDistance = 50;
                
                // Ordenar por confianza
                detections.sort((a, b) => b.confidence - a.confidence);
                
                for (const detection of detections) {
                    let shouldAdd = true;
                    
                    for (const existing of filtered) {
                        const distance = Math.sqrt(
                            Math.pow(detection.x - existing.x, 2) + 
                            Math.pow(detection.y - existing.y, 2)
                        );
                        
                        if (distance < minDistance) {
                            // Si está muy cerca, combinar información
                            if (detection.confidence > existing.confidence) {
                                existing.x = detection.x;
                                existing.y = detection.y;
                                existing.confidence = detection.confidence;
                            }
                            shouldAdd = false;
                            break;
                        }
                    }
                    
                    if (shouldAdd && detection.confidence > 0.3) {
                        filtered.push(detection);
                    }
                }
                
                return filtered.slice(0, 3);
            }
            
            // Sistema de tracking con suavizado
            function updateTracking(newDetections) {
                const currentTime = Date.now();
                const maxAge = 1000; // 1 segundo sin ver la forma
                const maxDistance = 80; // Distancia máxima para asociar
                
                // Marcar formas existentes como no vistas
                trackedShapes.forEach(shape => {
                    shape.seen = false;
                });
                
                // Procesar nuevas detecciones
                newDetections.forEach(detection => {
                    let bestMatch = null;
                    let bestDistance = Infinity;
                    
                    // Buscar la forma rastreada más cercana
                    trackedShapes.forEach((shape, id) => {
                        const distance = Math.sqrt(
                            Math.pow(shape.x - detection.x, 2) + 
                            Math.pow(shape.y - detection.y, 2)
                        );
                        
                        if (distance < maxDistance && distance < bestDistance) {
                            bestDistance = distance;
                            bestMatch = id;
                        }
                    });
                    
                    if (bestMatch) {
                        // Actualizar forma existente con suavizado
                        const shape = trackedShapes.get(bestMatch);
                        const smooth = 0.7; // Factor de suavizado
                        
                        shape.x = shape.x * (1 - smooth) + detection.x * smooth;
                        shape.y = shape.y * (1 - smooth) + detection.y * smooth;
                        shape.width = shape.width * (1 - smooth) + detection.width * smooth;
                        shape.height = shape.height * (1 - smooth) + detection.height * smooth;
                        shape.confidence = Math.max(shape.confidence * 0.9, detection.confidence);
                        shape.lastSeen = currentTime;
                        shape.seen = true;
                        shape.frameCount++;
                    } else {
                        // Nueva forma detectada
                        const id = `shape_${shapeIdCounter++}`;
                        trackedShapes.set(id, {
                            id: id,
                            x: detection.x,
                            y: detection.y,
                            width: detection.width,
                            height: detection.height,
                            confidence: detection.confidence,
                            firstSeen: currentTime,
                            lastSeen: currentTime,
                            seen: true,
                            frameCount: 1
                        });
                    }
                });
                
                // Remover formas perdidas
                const toRemove = [];
                trackedShapes.forEach((shape, id) => {
                    if (!shape.seen && (currentTime - shape.lastSeen) > maxAge) {
                        toRemove.push(id);
                    }
                });
                
                toRemove.forEach(id => trackedShapes.delete(id));
            }
            
            // Mostrar formas rastreadas
            function displayTrackedShapes() {
                trackedShapes.forEach(shape => {
                    // Solo mostrar formas estables (vistas al menos 3 frames)
                    if (shape.frameCount >= 3 && shape.confidence > 0.25) {
                        showTrackedShapeAt(shape);
                    }
                });
            }
            
            // Mostrar forma rastreada con seguimiento suave
            function showTrackedShapeAt(shape) {
                const rect = canvas.getBoundingClientRect();
                const scaleX = rect.width / canvas.width;
                const scaleY = rect.height / canvas.height;
                
                // Borde de detección que sigue la forma
                const border = document.createElement('div');
                border.style.position = 'absolute';
                border.style.left = (shape.x * scaleX) + 'px';
                border.style.top = (shape.y * scaleY) + 'px';
                border.style.width = (shape.width * scaleX) + 'px';
                border.style.height = (shape.height * scaleY) + 'px';
                border.style.border = '3px solid #2ecc71';
                border.style.borderRadius = '6px';
                border.style.zIndex = '5';
                border.style.animation = 'pulse 1.5s infinite';
                border.style.transition = 'all 0.1s ease-out';
                
                // Texto que sigue la forma suavemente
                const card = document.createElement('div');
                const cardX = (shape.x + shape.width + 15) * scaleX;
                const cardY = shape.y * scaleY;
                
                card.style.position = 'absolute';
                card.style.left = Math.min(cardX, window.innerWidth - 140) + 'px';
                card.style.top = Math.max(10, cardY) + 'px';
                card.style.background = 'rgba(46, 204, 113, 0.95)';
                card.style.color = 'white';
                card.style.padding = '10px 14px';
                card.style.borderRadius = '8px';
                card.style.fontFamily = 'Arial, sans-serif';
                card.style.fontSize = '14px';
                card.style.zIndex = '10';
                card.style.boxShadow = '0 3px 10px rgba(0,0,0,0.4)';
                card.style.whiteSpace = 'nowrap';
                card.style.transition = 'all 0.1s ease-out';
                
                card.innerHTML = `
                    <div style="font-weight: bold; margin-bottom: 2px;">
                        👋 Hola
                    </div>
                    <div style="font-size: 11px; opacity: 0.9;">
                        DAyE 2025 Expo
                    </div>
                `;
                
                arOverlay.appendChild(border);
                arOverlay.appendChild(card);
            }
            
            // Iniciar AR
            async function startAR() {
                try {
                    updateStatus('Iniciando...', 'detecting');
                    
                    stream = await navigator.mediaDevices.getUserMedia({
                        video: { 
                            facingMode: 'environment',
                            width: { ideal: 1280 },
                            height: { ideal: 720 }
                        }
                    });
                    
                    video.srcObject = stream;
                    
                    video.onloadedmetadata = function() {
                        setupCanvas();
                        isRunning = true;
                        updateStatus('Detectando...', 'active');
                        detectLoop();
                    };
                    
                } catch (error) {
                    console.error('Error:', error);
                    updateStatus('Error de cámara', 'ready');
                }
            }
            
            // Detener AR
            function stopAR() {
                isRunning = false;
                
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
                
                if (stream) {
                    stream.getTracks().forEach(track => track.stop());
                    stream = null;
                }
                
                if (video.srcObject) {
                    video.srcObject = null;
                }
                
                clearOverlay();
                updateStatus('Toca para iniciar', 'ready');
            }
            
            // Toggle AR
            function toggleAR() {
                if (isRunning) {
                    stopAR();
                } else {
                    startAR();
                }
            }
            
            // Event listeners
            statusIndicator.addEventListener('click', toggleAR);
            
            backBtn.addEventListener('click', function() {
                stopAR();
                window.location.href = 'index.html';
            });
            
            // Configuración inicial
            updateStatus('Toca para iniciar', 'ready');
            console.log('AR listo');
        });
    </script>
</body>
</html>
